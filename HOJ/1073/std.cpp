#include <iostream>
#include <cstring>//memset.
#include <vector>//representing paths.
#include <queue>//priority_queue.
#include <algorithm>//reverse, lexicographical_compare.
#include <functional>//greater.

using namespace std;

typedef char VT;//The type of vertex numbers.
typedef int LT;//The type of lengths of edges.

const VT MAX_VER = 50;
const LT MAX_LEN = 99999999;

struct Edge {
    VT to;
    LT len;
    Edge* next;

    Edge(VT t = 0, LT l = 0, Edge* n = NULL) {
	to = t; len = l; next = n;
    }
};

struct Path {
    vector<VT> node;
    vector<VT> block;
    LT len;

    //The index of the deviation node. Nodes before this node are on the
    //k shortest paths' tree.
    VT dev;

    //Initialize a path with only one vertex.
    Path(VT v = 0) : node(), block() { node.push_back(v); len = 0; }

    bool operator > (const Path& p) const {
	return len > p.len || len == p.len
	    && lexicographical_compare(
		    p.node.rbegin(), p.node.rend(),
		    node.rbegin(), node.rend() );
    }
};

ostream& operator << (ostream& os, const Path& p) {
    os << p.node[ p.node.size() - 1 ] + 1;
    for (int i = p.node.size() - 2; i >= 0; i--) {
	os << "-" << p.node[i] + 1;
    }
    return os;
}

class Graph {
    public:
	Graph() { memset(m_adj, 0, sizeof(m_adj)); }
	~Graph() { init(); }

	//Multiple edges between same pair of vertices are not allowed.
	void addEdge(VT from, VT to, LT len) {
	    if ( NULL == m_edge[from][to] ) {
		m_adj[from] = new Edge(to, len, m_adj[from]);
		m_edge[from][to] = m_adj[from];
	    }
	}

	//Can NOT handle graphs with NEGATIVE edges!!!
	void dijkstra() {
	    int minV;
	    for (int iter = 0; iter < m_verCnt; iter++) {
		minV = -1;
		for (int i = 0; i < m_verCnt; i++) {
		    if (!m_visit[i]
			    && ( -1 == minV || m_sh[i] < m_sh[minV] )
		       ) {
			minV = i;
		    }
		}
		if (-1 == minV) { break; }
		m_visit[minV] = true;
		for (Edge* adj = m_adj[minV]; adj; adj = adj->next) {
		    VT to = adj->to;
		    //The condition "!m_visit[to]" is suitable
		    //only for non-negative-edge graphs.
		    if (!m_visit[to] && !m_block[minV][to]) {
			relax(minV, to, adj->len);
		    }
		}
	    }
	}

	//Initialize a graph with "verCnt" vertices and no edge.
	void init(VT verCnt = MAX_VER) {
	    memset( m_edge, 0, sizeof(m_edge) );
	    m_verCnt = verCnt;
	    Edge* p, *temp;
	    for (VT i = 0; i < m_verCnt; i++) {
		p = m_adj[i];
		while (p) { temp = p; p = p->next; delete temp; }
		m_adj[i] = NULL;
	    }
	}

	//Get the k loopless shortest paths with YEN's algorithm.
	//If two paths have the same length, the one whose reversed path
	//has lexicographically lower value ranks first.
	vector<Path> yenLoopless(VT source, VT sink, int k) {
	    vector<Path> result;
	    priority_queue< Path, vector<Path>, greater<Path> > candidate;
	    memset(m_block, 0, sizeof(m_block));
	    initSingleSrc(source);
	    dijkstra();
	    if ( shortest(sink) < MAX_LEN ) {
		Path sh = shortestPath(sink);
		sh.dev = 1;
		sh.block.push_back( sh.node[sh.dev] );
		candidate.push(sh);
	    }
	    while ( result.size() < k && !candidate.empty() ) {
		Path p = candidate.top();
		candidate.pop();
		VT dev = p.dev;
		while ( dev < p.node.size() ) {
		    VT pre = p.node[dev - 1];
		    if (dev == p.dev) {
			for (int i = 0; i < p.block.size(); i++) {
			    m_block[pre][ p.block[i] ] = true;
			}
		    }
		    else { m_block[pre][ p.node[dev] ] = true; }
		    initSingleSrc(source);
		    delSubpath(p, dev);
		    dijkstra();

		    if (shortest(sink) < MAX_LEN) {
			Path newP = shortestPath(sink);
			newP.dev = dev;
			if (dev == p.dev) { newP.block = p.block; }
			else { newP.block.push_back( p.node[dev] ); }
			newP.block.push_back( newP.node[dev] );
			candidate.push(newP);
		    }

		    dev++;
		}
		memset(m_block, 0, sizeof(m_block));
		result.push_back(p);
	    }
	    return result;
	}

	Path shortestPath(VT v) const {
	    Path p(v);
	    p.len = m_sh[v];
	    for (v = m_pre[v]; -1 != v; v = m_pre[v]) {p.node.push_back(v);}
	    reverse( p.node.begin(), p.node.end() );
	    return p;
	}

	//The shortest distance from the source to v
	//(after solving the single source shortest paths).
	LT shortest(VT v) const { return m_sh[v]; }

    private:
	//Determine leading subpath of the shortest path generated by
	//dijkstra().
	void delSubpath(const Path& p, VT dev) {
	    VT pre = p.node[0];
	    m_visit[pre] = true;
	    int v;
	    for (VT i = 1; dev != i; i++) {
		v = p.node[i];
		m_pre[v] = pre;
		m_sh[v] = m_sh[pre] + m_edge[pre][v]->len;
		m_visit[v] = true;
		pre = v;
	    }
	    m_visit[pre] = false;
	}

	//Initialize the single source shortest path algorithms.
	void initSingleSrc(VT source) {
	    for (VT i = 0; i < m_verCnt; i++) {
		m_sh[i] = MAX_LEN;
		m_pre[i] = -1;
		m_visit[i] = false;
	    }
	    m_sh[source] = 0;
	}

	//Help the shortest path algorithms.
	bool relax(VT from, VT to, LT len) {
	    if (m_sh[to] > m_sh[from] + len) {
		m_sh[to] = m_sh[from] + len; m_pre[to] = from; return true;
	    }
	    //With the following condition, the REVERSE shortest path with be
	    //the LEXICOGRAPHICALLY first one.
	    else if (m_sh[to] == m_sh[from] + len && from < m_pre[to]) {
		m_pre[to] = from; return true;
	    }
	    return false;
	}

	VT m_verCnt;//Number of vertices.
	Edge* m_adj[MAX_VER];//Adjacent list.
	LT m_sh[MAX_VER];//Every vertex's shortest distance from the source.
	VT m_pre[MAX_VER];//The previous vertex in the shortest path.
	//m_edge[i][j]: the edge from i to j. NULL value if no edge (i, j).
	Edge* m_edge[MAX_VER][MAX_VER];
	bool m_visit[MAX_VER];//Help the dijkstra.

	//Help to make acyclic paths.
	bool m_block[MAX_VER][MAX_VER];
};

//To get the lexicographically first shortest path,
//I reverse the graph. See the input() function.
Graph g_revGraph;
int g_k;
int g_source;
int g_sink;

bool input() {
    int verCnt;
    int eCnt;
    cin >> verCnt >> eCnt >> g_k >> g_source >> g_sink;
    g_source--; g_sink--;//I number the vertices from 0 to n - 1.
    if (0 == verCnt) { return false; }
    g_revGraph.init(verCnt);
    int from, to, len;
    for (int i = 0; i < eCnt; i++) {
	cin >> from >> to >> len;
	from--; to--;
	g_revGraph.addEdge(to, from, len);//Edges are reversed.
    }
    return true;
}

void solve() {
    //The source and sink are reversed in the reversed graph.
    vector<Path> kSh = g_revGraph.yenLoopless(g_sink, g_source, g_k);
    if (kSh.size() < g_k) { cout << "No" << endl; }
    else { cout << kSh[g_k - 1] << endl; }
}

int main() {
    input();
	solve();
    return 0;
}
